module rom(
	clk,
	cs,
	addr,
	data1,
	data2
);

integer               tw_file     ; // var to see if file exists
integer               scan_inputs     ; // captured text handler

//TXT
//reg [127:0] captured_outputs; ///Actual text obtained from outputs.txt lines
reg [127:0] twiddle;  ///Actual text obtained from inputs.txt lines


parameter WORDSIZE = 16; 	// word size 16-bits
parameter ADDRSIZE = 5;		// number of bits in address
parameter NUMADDR = 8;		// number of addresses

input clk, cs, addr;
output data1, data2;

wire clk;
wire cs;
wire [ADDRSIZE-1:0] addr;
wire [WORDSIZE-1:0] data1, data2;

reg [WORDSIZE-1:0] memory [0:NUMADDR/2-1];
reg [WORDSIZE-1:0] data1_r, data2_r;

integer i;

assign data1 = cs ? data1_r : {WORDSIZE{1'bz}};
assign data2 = cs ? data2_r : {WORDSIZE{1'bz}};
/*
initial 
begin

  // TEXT FILE inputs///////////////////////
    tw_file = $fopen("twiddle.dat", "r"); //Opening text file (inputs)
      if (tw_file == 0) begin               //If inputs file is not found
        $display("data_file handle was NULL");
        $finish;
      end
end

always @(* )
begin

   if (!$feof(tw_file)) 
   begin
   ///!$feof means if not reaching the end of file
   ///file_outputs is always returning a different number other than "0" if the doc 
   ///has not ended. When reaching "0" it means the doc is over.
   ///Since both of my docs are the same length I'm only validating one of them
   ///but if you have different lenghts you should verify each doc you're reading
	
   scan_inputs = $fscanf(tw_file, "%h\n", twiddle);        //Inputs Line text
	memory[i] = twiddle;
	i = i+1;
   $display ("Line :[inputs: %h _ outputs: %h ]", twiddle);  
   // Displaying each line at the simulation monitor

   ///$fscanf means formatted text, $scanf would read text ignoring the format
   /// %h\n means it should expect HEX numbers and the end of line character, that means 
   /// the line is over, but if you want to use a diff criteria 
   /// you can replace \n to whatever you may need 

   end
   else
   begin
   $finish;
   $fclose(twiddle);

   end

end*/

initial
begin
	data1_r <= 0;
	data2_r <= 0;

   $readmemh("twiddle32.dat", memory);

	
//	memory[0]  <= 16'h0000; memory[1]  <= 16'h0000; memory[2]  <= 16'h0000; memory[3]  <= 16'h0000;
//	memory[4]  <= 16'h0000; memory[5]  <= 16'h0000; memory[6]  <= 16'h0000; memory[7]  <= 16'h0000;
//	memory[8]  <= 16'h0000; memory[9]  <= 16'h0000; memory[10] <= 16'h0000; memory[11] <= 16'h0000;
//	memory[12] <= 16'h0000; memory[13] <= 16'h0000; memory[14] <= 16'h0000; memory[15] <= 16'h0000;
//	memory[16] <= 16'h0000; memory[17] <= 16'h0000; memory[18] <= 16'h0000; memory[19] <= 16'h0000;
//	memory[20] <= 16'h0000; memory[21] <= 16'h0000; memory[22] <= 16'h0000; memory[23] <= 16'h0000;
//	memory[24] <= 16'h0000; memory[25] <= 16'h0000; memory[26] <= 16'h0000; memory[27] <= 16'h0000;
//	memory[28] <= 16'h0000; memory[29] <= 16'h0000; memory[30] <= 16'h0000; memory[31] <= 16'h0000;
//	memory[32] <= 16'h0000; memory[33] <= 16'h0000; memory[34] <= 16'h0000; memory[35] <= 16'h0000;
//	memory[36] <= 16'h0000; memory[37] <= 16'h0000; memory[38] <= 16'h0000; memory[39] <= 16'h0000;
//	memory[40] <= 16'h0000; memory[41] <= 16'h0000; memory[42] <= 16'h0000; memory[43] <= 16'h0000;
//	memory[44] <= 16'h0000; memory[45] <= 16'h0000; memory[46] <= 16'h0000; memory[47] <= 16'h0000;
//	memory[48] <= 16'h0000; memory[49] <= 16'h0000; memory[50] <= 16'h0000; memory[51] <= 16'h0000;
//	memory[52] <= 16'h0000; memory[53] <= 16'h0000; memory[54] <= 16'h0000; memory[55] <= 16'h0000;
//	memory[56] <= 16'h0000; memory[57] <= 16'h0000; memory[58] <= 16'h0000; memory[59] <= 16'h0000;
//	memory[60] <= 16'h0000; memory[61] <= 16'h0000; memory[62] <= 16'h0000; memory[63] <= 16'h0000;
end

always @(posedge clk)
begin : READ
	data1_r <= memory[addr];
	data2_r <= memory[addr+NUMADDR/4];
end

endmodule
